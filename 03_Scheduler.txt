Update 2026.01.15
스케쥴 함수는 기본 구조체 변수를 호출 하게 변경 하였습니다.
이유는 LCD 같은 동일 구조의 여러개 동작시 불필요한 동일 함수를 사용 하기 위해 설계변경됨.
Scheduler control modify : void f_Job(void) -> void f_Job(Struct *)

Module 구성은 다음과 같이 구성이 됩니다.
Module
  ↓
Job → Step(case)
  ↓
Action (복잡한 경우)
  ↓
Step(case)

Schedule table : Job 실행 순서를 정리한 table 을 이야기합니다.

1. Module은 어느 장치의 동작을 관리합니다.
 예시) LCD, GPS, CAMERA 형태 Module.
1.1 모듈 안에는 Mode 로 세분화 되어 Table을 관리합니다.
 예시) LCD 18Bit Mode, LCD 16Bit Mode

2. Job 어느 동작에 필요한 수행을 합니다.
 예시) LCD 18Bit 통신 설정, LCD 16Bit 통신 설정, LCD 시작 위치 변경

3. Action 보통 Job 에서 Switch step 으로 넘어가나 내용이 많거나 
  step이 10이상 넘어가는 경우 Action 이라는 하위 계층으로 다시 세분화 할 수 있습니다.

Poling 방식의 구조를 규격화 하기위한 제어 모듈 설명
RTOS 처럼 Context Switch를 통한 Task 점유을 제어가 아닌 폴링 방식의 동작 스케쥴을 제어하기 위한 구조임.

세부 Step 을 나누는 기준은 전송 시점 입니다.
UART, SPI, DMA 등 전송을 하고 다음 STEP을 넘어갑니다.
대기를 하지 않고 전송중에 다른 작업을 하기 위해 넘어가며
폴링 방식으로 전송 완료 시점이 완료 될때 까지 대기

기본 컨셉은 기다릴경우 다른 Module 에게 시간을 넘김니다.
폴링 방식이기 때문에 각 Module의 사용 시간은 1ms 이내로 처리 합니다.




typedef enum{
    m_SCH_ERROR_CODE_NO_ERROR,      /* 에러 없음 (No error)*/
    m_SCH_ERROR_CODE_TIME_OUT,      /* 타임 아웃 (Timeout)*/
    m_SCH_ERROR_CODE_CRC,           /* CRC 에러 */
    m_SCH_ERROR_CODE_DATA,
    m_SCH_ERROR_CODE_READ,
    m_SCH_ERROR_CODE_READ_OVF,
    m_SCH_ERROR_CODE_WRITE,
    m_SCH_ERROR_CODE_WRITE_OVF
}te_SCH_Error_Code;


typedef struct{
    /* 제어 변수 */
    uint32 v_active;                    // 0: Disable, 1 ~ 0xFFFFFFFF: 1은 활성  1이상 < skip count 2는 2회 마다 한번수행;
    uint32 v_skip;                      // 부하를 줄이기 위해 SKIP 단위 설정.
    uint32 v_priority;                  // 우선 순위등급 높을수록 높음 

    /* Schedule 테이블 정보 */
    void (**ps_wf_table)(void);         // Workflow 테이블 리스트.
    uint32 v_wf_table_size;             // Workflow 태이블 사이즈 정보.
    uint32 v_wf_table_pos;              // workflow 태이블 위치 정보.
    void (*pf_wf_func)(void);           // Workflow 함수 포인터.
    uint32 v_wf_next_delay;             // Workflow 다음 동작시 대기시간 (us).
    uint32 v_wf_time;                   // Workflow 수행 시간 (us).
    uint32 v_wf_time_avg;               // Workflow 수행 시간 평균 10회 (us).
    uint32 v_wf_time_max;               // Workflow 수행 시간 최대 (us).

    /* JOB 테이블 */
    void (**ps_job_table)(void);        // job 테이블
    uint32 v_job_table_size;            // Job 테이블 사이즈
    uint32 v_job_table_pos;             // Job 테이블 위치.
    void (*pf_job_func)(void);          // job 함수
    uint32 v_job_next_delay;            // job 다음 동작시 대기시간 (us).
    uint32 v_job_setp_pos;              // job 함수 내부 Switch 위치 정보.
    uint32 v_job_timeout;               // job 타임 아웃.

    /* 에러 정보 */
    uint32 v_error_pos;                 // Schedule error position.
    uint32 v_error_step;                // Schedule error step(case) postion.
    te_SCH_Error_Code e_error_code;     // Schedule error code.
    uint32 v_error_count;               // Schedule error total count.
}ts_SCH_ctrl;

/* 스케쥴러 테이블 Main 타임 함수 */
static void (*pf_base_main_schedule_table[d_BASE_MAIN_TABLE_SIZE])(void) = {
    f_Base_Main_TBase_1ms,
    f_Base_Main_TBase_10ms,
    f_Base_Main_TBase_100ms,
    f_Base_Main_TBase_500ms,
    f_Base_Main_TBase_1s
};
/* scheduler 제어 변수)
ts_SCH_ctrl gs_base_main_sch_ctrl;
